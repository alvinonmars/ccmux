"""Reconcile ccmux.toml timer definitions with systemd user units.

Reads [timers] and [services] from ccmux.toml, generates/updates systemd
timer+service files, cleans orphans, and verifies managed services.

Entry points:
    ccmux-deploy  →  deploy()   (manual or ccmux-reconcile.service)
    ccmux-verify  →  verify()   (health check)
"""
from __future__ import annotations

import os
import subprocess
import sys
from pathlib import Path

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomllib  # type: ignore[import]
    except ModuleNotFoundError:
        import tomli as tomllib  # type: ignore[no-redef]

SYSTEMD_USER_DIR = Path.home() / ".config" / "systemd" / "user"
TIMER_PREFIX = "ccmux-"
TARGET = "ccmux.target"


# ---------------------------------------------------------------------------
# TOML loading
# ---------------------------------------------------------------------------

def _find_project_root() -> Path:
    """Walk up from cwd or script location to find ccmux.toml."""
    candidates = [Path.cwd(), Path(__file__).resolve().parent.parent]
    for base in candidates:
        if (base / "ccmux.toml").exists():
            return base
    print("ERROR: ccmux.toml not found")
    sys.exit(1)


def _load_toml(project_root: Path) -> dict:
    toml_path = project_root / "ccmux.toml"
    with open(toml_path, "rb") as f:
        return tomllib.load(f)


# ---------------------------------------------------------------------------
# systemd file generation
# ---------------------------------------------------------------------------

def _timer_unit(name: str, timer_cfg: dict) -> str:
    desc = timer_cfg.get("description", f"ccmux timer: {name}")
    schedule = timer_cfg.get("schedule")
    startup_delay = timer_cfg.get("startup_delay")

    if not schedule and not startup_delay:
        raise ValueError(
            f"Timer '{name}' must have at least 'schedule' or 'startup_delay'"
        )

    trigger_lines: list[str] = []

    if startup_delay:
        trigger_lines.append(f"OnActiveSec={startup_delay}")

    if schedule:
        if isinstance(schedule, list):
            trigger_lines.extend(f"OnCalendar={s}" for s in schedule)
        else:
            trigger_lines.append(f"OnCalendar={schedule}")

    triggers = "\n".join(trigger_lines)

    # Only add Persistent=true when calendar schedules are present
    persistent = "\nPersistent=true" if schedule else ""

    return f"""\
# Auto-generated by ccmux reconcile — do not edit manually
[Unit]
Description={desc}
PartOf={TARGET}

[Timer]
{triggers}{persistent}

[Install]
WantedBy={TARGET}
"""


def _timer_service_unit(name: str, timer_cfg: dict, project_root: Path) -> str:
    desc = timer_cfg.get("description", f"ccmux timer service: {name}")
    exec_cmd = timer_cfg["exec"]
    syslog = timer_cfg.get("syslog", f"ccmux-{name}")

    # Build Environment lines
    env_lines = f"Environment=HOME={Path.home()}\n"
    env_dict = timer_cfg.get("env", {})
    for k, v in env_dict.items():
        env_lines += f"Environment={k}={v}\n"

    return f"""\
# Auto-generated by ccmux reconcile — do not edit manually
[Unit]
Description={desc}
After=ccmux.service

[Service]
Type=oneshot
WorkingDirectory={project_root}
ExecStart={project_root / exec_cmd}
{env_lines.rstrip()}
StandardOutput=journal
StandardError=journal
SyslogIdentifier={syslog}
"""


def _write_if_changed(path: Path, content: str) -> bool:
    """Write file only if content differs. Returns True if written."""
    if path.exists() and path.read_text() == content:
        return False
    path.write_text(content)
    return True


# ---------------------------------------------------------------------------
# Reconcile logic
# ---------------------------------------------------------------------------

def _reconcile_timers(data: dict, project_root: Path) -> tuple[int, int, int]:
    """Generate/update timer files, clean orphans. Returns (created, updated, removed)."""
    timers = data.get("timers", {})
    SYSTEMD_USER_DIR.mkdir(parents=True, exist_ok=True)

    expected_timer_files: set[str] = set()
    created = updated = 0

    for name, cfg in timers.items():
        unit_name = f"{TIMER_PREFIX}{name}"
        timer_path = SYSTEMD_USER_DIR / f"{unit_name}.timer"
        service_path = SYSTEMD_USER_DIR / f"{unit_name}.service"
        expected_timer_files.add(f"{unit_name}.timer")
        expected_timer_files.add(f"{unit_name}.service")

        timer_content = _timer_unit(name, cfg)
        service_content = _timer_service_unit(name, cfg, project_root)

        timer_is_new = not timer_path.exists()
        t_changed = _write_if_changed(timer_path, timer_content)
        s_changed = _write_if_changed(service_path, service_content)

        if timer_is_new:
            created += 1
            print(f"  + created {unit_name}.timer + .service")
        elif t_changed or s_changed:
            updated += 1
            print(f"  ~ updated {unit_name}.timer/.service")

    # Clean orphan timer files (ccmux-*.timer not in toml)
    removed = 0
    for f in SYSTEMD_USER_DIR.glob(f"{TIMER_PREFIX}*.timer"):
        if f.name not in expected_timer_files:
            unit_name = f.stem
            # Disable before removing
            subprocess.run(
                ["systemctl", "--user", "disable", "--now", f.name],
                capture_output=True,
            )
            f.unlink(missing_ok=True)
            # Also remove corresponding service
            svc_file = SYSTEMD_USER_DIR / f"{unit_name}.service"
            svc_file.unlink(missing_ok=True)
            removed += 1
            print(f"  - removed orphan {f.name}")

    return created, updated, removed


def _verify_services(data: dict) -> list[str]:
    """Verify managed services exist and have PartOf. Returns list of warnings."""
    managed = data.get("services", {}).get("managed", [])
    warnings: list[str] = []

    for svc_name in managed:
        svc_file = SYSTEMD_USER_DIR / f"{svc_name}.service"
        if not svc_file.exists():
            warnings.append(f"MISSING: {svc_name}.service not found")
            continue

        content = svc_file.read_text()
        if f"PartOf={TARGET}" not in content:
            warnings.append(f"NO PartOf: {svc_name}.service missing PartOf={TARGET}")

        # Check enabled
        result = subprocess.run(
            ["systemctl", "--user", "is-enabled", f"{svc_name}.service"],
            capture_output=True, text=True,
        )
        if result.stdout.strip() not in ("enabled", "static"):
            warnings.append(f"NOT ENABLED: {svc_name}.service")

    return warnings


def _enable_and_start_timers(data: dict) -> None:
    """Enable and start all declared timers."""
    timers = data.get("timers", {})
    for name in timers:
        unit_name = f"{TIMER_PREFIX}{name}.timer"
        subprocess.run(
            ["systemctl", "--user", "enable", unit_name],
            capture_output=True,
        )
        subprocess.run(
            ["systemctl", "--user", "start", unit_name],
            capture_output=True,
        )


def _daemon_reload() -> None:
    subprocess.run(["systemctl", "--user", "daemon-reload"], capture_output=True)


# ---------------------------------------------------------------------------
# Public entry points
# ---------------------------------------------------------------------------

def deploy() -> None:
    """Reconcile toml → systemd. Called by ccmux-deploy or ccmux-reconcile.service."""
    project_root = _find_project_root()
    data = _load_toml(project_root)

    print("ccmux reconcile: syncing toml → systemd")
    print(f"  project: {project_root}")

    # 1. Generate/update/clean timers
    created, updated, removed = _reconcile_timers(data, project_root)

    # 2. Reload if anything changed
    if created or updated or removed:
        print("  reloading systemd daemon...")
        _daemon_reload()

    # 3. Enable and start timers
    _enable_and_start_timers(data)

    # 4. Verify managed services
    warnings = _verify_services(data)

    # Report
    timers = data.get("timers", {})
    print(f"\n  Timers: {len(timers)} defined, {created} created, {updated} updated, {removed} orphans removed")
    if warnings:
        print(f"  Warnings ({len(warnings)}):")
        for w in warnings:
            print(f"    ⚠ {w}")
    else:
        managed = data.get("services", {}).get("managed", [])
        print(f"  Services: {len(managed)} managed, all OK")

    print("  reconcile complete.")


def verify() -> None:
    """Health check: show status of all managed services and timers."""
    project_root = _find_project_root()
    data = _load_toml(project_root)

    print("ccmux verify: checking system health\n")

    # Check services
    managed = data.get("services", {}).get("managed", [])
    print("Services:")
    for svc_name in managed:
        result = subprocess.run(
            ["systemctl", "--user", "is-active", f"{svc_name}.service"],
            capture_output=True, text=True,
        )
        status = result.stdout.strip()
        icon = "✅" if status == "active" else "❌"
        # Get PID if active
        pid = ""
        if status == "active":
            pid_result = subprocess.run(
                ["systemctl", "--user", "show", f"{svc_name}.service", "--property=MainPID", "--value"],
                capture_output=True, text=True,
            )
            pid = f" (pid {pid_result.stdout.strip()})"
        print(f"  {icon} {svc_name}: {status}{pid}")

    # Check timers
    timers = data.get("timers", {})
    print("\nTimers:")
    for name in timers:
        unit_name = f"{TIMER_PREFIX}{name}.timer"
        result = subprocess.run(
            ["systemctl", "--user", "is-active", unit_name],
            capture_output=True, text=True,
        )
        status = result.stdout.strip()
        icon = "✅" if status == "active" else "❌"
        # Get next trigger
        next_trigger = ""
        if status == "active":
            next_result = subprocess.run(
                ["systemctl", "--user", "show", unit_name, "--property=NextElapseUSecRealtime", "--value"],
                capture_output=True, text=True,
            )
            next_trigger = f" → next: {next_result.stdout.strip()}"
        print(f"  {icon} {name}: {status}{next_trigger}")

    # Check tmux session health
    project = data.get("project", {})
    project_name = project.get("name") or os.path.basename(project_root)
    tmux_session = f"ccmux-{project_name}"
    print(f"\nTmux session ({tmux_session}):")
    tmux_result = subprocess.run(
        ["tmux", "has-session", "-t", tmux_session],
        capture_output=True,
    )
    if tmux_result.returncode == 0:
        # Check if claude is actually running in the pane
        capture = subprocess.run(
            ["tmux", "capture-pane", "-t", tmux_session, "-p"],
            capture_output=True, text=True,
        )
        pane_text = capture.stdout.strip()
        has_claude_prompt = "❯" in pane_text
        has_error = "API Error" in pane_text or "Please run /login" in pane_text
        if has_error:
            print(f"  ❌ session exists but Claude has errors")
        elif has_claude_prompt:
            print(f"  ✅ session alive, Claude prompt detected")
        else:
            print(f"  ⚠  session exists, Claude state unknown")
    else:
        print(f"  ❌ tmux session not found")

    # Check proxy connectivity
    proxy_cfg = data.get("claude", {}).get("proxy", "")
    if proxy_cfg:
        import re
        m = re.search(r":(\d+)$", proxy_cfg)
        proxy_port = m.group(1) if m else None
        if proxy_port:
            proxy_result = subprocess.run(
                ["nc", "-z", "127.0.0.1", proxy_port],
                capture_output=True, timeout=3,
            )
            icon = "✅" if proxy_result.returncode == 0 else "❌"
            print(f"\nProxy ({proxy_cfg}):")
            print(f"  {icon} port {proxy_port} {'reachable' if proxy_result.returncode == 0 else 'UNREACHABLE'}")

    # Check consistency
    warnings = _verify_services(data)
    if warnings:
        print(f"\n⚠ Warnings:")
        for w in warnings:
            print(f"  {w}")
    else:
        print(f"\n✅ All {len(managed)} services + {len(timers)} timers OK")


def main() -> None:
    """CLI entry point for ccmux-deploy."""
    if len(sys.argv) > 1 and sys.argv[1] == "verify":
        verify()
    else:
        deploy()


if __name__ == "__main__":
    main()
