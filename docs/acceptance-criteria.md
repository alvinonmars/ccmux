# ccmux — Acceptance Criteria and Test Cases

## Test Strategy

| Layer | Scope | Fixture | Claude binary? | How to run |
|-------|-------|---------|---------------|------------|
| **Unit** | Protocol parsing, state machines, pure logic | None | No | `pytest tests/unit/` |
| **Integration/mock** | ccmux I/O mechanics: FIFO, inotify, injection, ready detection, pubsub, crash recovery, shutdown | daemon + mock fixtures | No | `pytest tests/integration/ -m "not real_claude"` |
| **Integration/real** | Claude Code-specific behaviors: hook firing, transcript format, MCP tool invocation, real permission prompt | daemon + real `claude` | **Yes** | `pytest tests/integration/ -m real_claude` |
| **E2E smoke** | Full user story: message in → Claude responds → adapter receives | running system | Yes | Manual checklist |

**Automated iteration loop**: Unit + Integration/mock. These run fast (no AI latency) and require no subscription.

### Iteration Closure Protocol

Before marking any iteration complete:

1. Run **parallel multi-round closure checking** using an agent team. Agent count is determined by the complexity of the iteration, not fixed.
2. Agents run with **bypassPermissions** so they can execute tests, read code, and verify behavior directly.
3. Fix every issue found. Repeat until **2 consecutive rounds find zero new issues**.
4. Only then mark the iteration complete.

**Checking angles** (assign one or more per agent based on scope):

- **Spec → Implementation**: Every AC sentence has matching code. Claims not tested are moved to the right AC or explicitly excluded.
- **Tests → Spec**: Tests cover all cases, edge cases, error paths, boundary conditions. Assertions are genuine (not trivially true, e.g. 0==0). Run the actual tests.
- **Integration**: Outputs interact correctly with adjacent components. Gaps are in Known Issues. Empirical behavior matches documented claims.

**Integration/real tests** are marked `@pytest.mark.real_claude` and skipped by default. Run locally before any significant change to Claude Code integration points. Require: claude binary in PATH, HTTP proxy configured, Claude Max auth active. Each test takes 15–30s (one real Claude turn).

**Behaviors that REQUIRE real Claude Code** (cannot be substituted by mock_pane):

| Behavior | Why mock is insufficient |
|---------|------------------------|
| Hook actually fires after claude starts | The hook invocation is inside the claude binary |
| `SessionStart` carries correct `session_id` and `transcript_path` | Generated by claude, format must match ccmux's parser |
| `Stop` hook fires per-turn with correct timing | claude decides when to fire; mock calling hook.py manually skips this |
| Transcript JSONL contains real `tool_use` / `thinking` blocks | Mock writes inferred format; real format may differ in field names or nesting |
| MCP server connected and `send_to_channel` callable by claude | Claude Code's MCP client must discover, connect, and call the tool |
| Real permission prompt text and format | Mock text `Allow this action? Yes/No` may not match claude's actual output |

**Test fixture tiers** (defined in `tests/conftest.py`):

- `daemon` — starts ccmux daemon with test config (`ccmux-test-{pid}` session name, ephemeral port)
- `bare_pane` — tmux pane running `cat`; sufficient for injection and terminal activity tests
- `mock_pane` — tmux pane running `mock_pane.py`; required for stdout-pattern and hook-chain tests
- `fire_hook(event, data)` — helper that directly calls `ccmux/hook.py` with crafted JSON; decouples hook-firing from the pane process where not needed

### mock_pane Process Specification

Located at `tests/helpers/mock_pane.py`. A **configurable I/O process** that runs inside a tmux pane and produces the I/O patterns that real Claude Code would produce. It does not simulate Claude's intelligence — only its observable I/O behavior as established by the spikes.

**Environment variables**:

| Variable | Default | Description |
|----------|---------|-------------|
| `MOCK_PROMPT` | `❯ ` | Prompt string output when waiting for input (ready state) |
| `MOCK_REPLY` | `mock reply` | Reply text output each turn |
| `MOCK_DELAY` | `0.1` | Seconds between receiving input and outputting reply |
| `MOCK_TRANSCRIPT` | `""` | Transcript file path; if set, appends a valid JSONL line after each reply |
| `MOCK_HOOK_SCRIPT` | `""` | Hook script path; if set, called after each reply with Stop hook JSON on stdin |
| `MOCK_SPINNER` | `0` | If > 0, emits N spinner sequences (`\x1b[?2026l\x1b[?2026h✻`, 0.1s apart) before reply |
| `MOCK_CONTINUOUS_SPINNER` | `0` | If > 0, emits spinner sequences every 0.1s indefinitely until next stdin arrives; overrides `MOCK_SPINNER` |
| `MOCK_PERMISSION_INTERVAL` | `0` | If > 0, every N turns: output permission prompt text, call hook with PermissionRequest JSON, pause for stdin |

**Behavior loop**:
1. On start: output `$MOCK_PROMPT`
2. On stdin input: wait `$MOCK_DELAY` seconds
3. If `MOCK_CONTINUOUS_SPINNER > 0`: emit spinner sequences every 0.1s until next stdin arrives, then go to step 2
4. Else if `MOCK_SPINNER > 0`: emit N spinner sequences (0.1s apart)
5. If this is a permission turn (`MOCK_PERMISSION_INTERVAL > 0` and `turn % interval == 0`):
   - Output `Allow this action? Yes/No`
   - If `MOCK_HOOK_SCRIPT` set: call hook script with `{"hook_event_name": "PermissionRequest", ...}` on stdin
   - Wait for next stdin (simulates human resolving the prompt); then continue
6. Output `$MOCK_REPLY`
7. If `MOCK_TRANSCRIPT` set: append one JSONL line to the file
8. If `MOCK_HOOK_SCRIPT` set: call hook script with Stop hook JSON on stdin (includes `transcript_path`, `session_id`)
9. Output `$MOCK_PROMPT` again; go to step 2

**Transcript JSONL line format** (matches SP-01 verified format):
```json
{"message": {"role": "assistant", "content": [{"type": "text", "text": "$MOCK_REPLY"}]}, "ts": 1740000000}
```

**Fixture and layer mapping**:

| AC | Layer | Fixture |
|----|-------|---------|
| AC-00 T-00-1 (fresh start) | Integration/**real** | real `claude` |
| AC-00 T-00-2/3/4 | Integration/mock | `daemon` only |
| AC-01 (FIFO accept) | Integration/mock | `daemon` only |
| AC-02 (inotify) | Integration/mock | `daemon` only |
| AC-03 (injection) | Integration/mock | `bare_pane` + `fire_hook` |
| AC-04 (terminal activity) | Integration/mock | `bare_pane` |
| AC-05 (ready detection) | Integration/mock | `mock_pane` (T-05-1/2/4/5/6); `bare_pane` (T-05-3) |
| AC-06 T-06-1/2/3/4 | Integration/mock | `fire_hook` → output.sock |
| AC-06 T-06-real (full pipeline) | Integration/mock | `net_daemon` + `fire_hook` (hook.py subprocess → control.sock → output.sock) |
| AC-07 T-07-1/4 | Integration/mock | `fire_hook` with crafted transcript |
| AC-07 T-07-2/3 (tool_use, thinking) | Integration/**real** | real `claude` turn |
| AC-08 (MCP tool) | Integration/**real** | real `claude` calls tool |
| AC-09 (crash recovery) | Integration/mock | `_FakePane` (monkeypatched `_is_claude_running`; real process detection untested) |
| AC-10 (logging) | Integration/mock | asserts on log from above tests |
| AC-11 (graceful shutdown) | Integration/mock | `daemon` only |
| AC-12 (daemon restart) | Integration/mock | `mock_pane` |
| AC-13 T-13-1 (PermissionRequest hook + alert) | Integration/mock | `net_daemon` + `fire_hook("PermissionRequest")` + output.sock subscriber |
| AC-13 T-13-2 (capture-pane fallback) | Integration/mock | `bare_pane` (typed permission text, no MOCK_HOOK_SCRIPT) |
| AC-13 T-13-3 (injection resumes) | Integration/mock | `net_daemon` + `fire_hook("PermissionRequest")` + `fire_hook("Stop")` + `bare_pane` |
| AC-13 T-13-4 (capture-pane recovery) | Integration/mock | `bare_pane` (no permission text) + `_permission_detected=True` |

---

## Spikes (one-time pre-implementation validation)

Located in `tests/spikes/`. Each spike is an independently runnable program. All spikes are complete; findings are frozen in spec.md.

### SP-01: Claude Code stop hook data format ✅

**Validation goals**:
- JSON field structure of the hook script's stdin
- How to obtain the transcript file path
- Hook trigger timing (per-turn vs per-session)

**Findings (frozen)**:
- [x] Transcript path: `stdin["transcript_path"]`, format `~/.claude/projects/<hash>/<session_id>.jsonl` (no `conversations/` subdirectory)
- [x] Trigger timing: once after each assistant turn (confirmed by SP-05 interactive mode test)
- [x] Thinking block field name: did not appear in `-p` mode; inferred as `"thinking"` from API docs; treated as optional in implementation

---

### SP-02: Claude Code stdout prompt and permission prompt detection ✅

**Validation goals**:
- stdout byte sequence when Claude Code is waiting for input
- stdout byte sequence during generation
- Reliable way to distinguish the two states

**Findings (frozen)**:
- [x] During generation: stdout emits `\x1b[?2026l\x1b[?2026h` + spinner chars multiple times per second
- [x] Ready state: stdout completely silent; 3 consecutive seconds with no new bytes = ready
- [x] Auxiliary confirmation: last line of `tmux capture-pane -p` contains `❯` when ready
- [x] Permission prompt detection: `capture-pane` text search for `Yes`/`No`/`allow`/`y/n` keywords
- [x] `pipe-pane -O` reliably captures stdout; production-ready

---

### SP-03: FIFO concurrent write and non-blocking read ✅

**Validation goals**:
- Whether lines interleave when multiple processes write to the same FIFO concurrently
- Behavior of `open`/`read` in O_NONBLOCK mode when no writer exists
- Whether the reader correctly detects EOF when all writers close

**Findings (frozen)**:
- [x] Short messages (< 4096B): writes are atomic, no data interleaving
- [x] O_NONBLOCK open with no writer: `open()` returns immediately; `read()` returns `b''`; no ENXIO
- [x] Correct pattern for daemon FIFO reads: `O_NONBLOCK` + `select` + `os.read()`; `readline()` is forbidden

---

### SP-04: tmux send-keys injection behavior ✅

**Validation goals**:
- Whether Unicode/Chinese characters inject correctly
- Whether shell special characters are interpreted
- `-l` flag behavior

**Findings (frozen)**:
- [x] Use `-l` flag: `tmux send-keys -l 'content'` + `tmux send-keys Enter` (two commands; Enter sent separately)
- [x] Special characters (Chinese, `$`, backtick, `!`, `"`, `'`, `\`, `[]`, `{}`, `|`, `;`, `*`) require no extra escaping; injection is lossless

---

### SP-05: Complete hook event types + agent team behavior ✅

**Validation goals**:
- All valid hook event types
- Which session_id sub-agent hooks report
- Side effects of PreToolUse/PostToolUse

**Findings (frozen)**:
- [x] Stop hook fires per turn in interactive mode (corrects SP-01's -p mode misreading)
- [x] SubagentStart/Stop report the leader's session_id; leader's Stop hook includes complete team output
- [x] PreToolUse/PostToolUse fire for all claude instances on the machine — **ccmux does not install these**
- [x] Correct hook format: `[{"hooks": [{"type": "command", "command": "..."}]}]` (nested, not flat)
- [x] SessionStart carries session_id; usable for transcript path discovery

---

## Acceptance Criteria and Test Cases

### AC-00 Startup Sequence

**Criterion**: After `ccmux start`, hooks are installed, the MCP server is up, claude is running in tmux, and pipe-pane is mounted.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-00-1 | Fresh start | Run `ccmux start` (no existing tmux session) | hooks written to settings.json; MCP server socket exists; claude process running in tmux pane; `/tmp/ccmux/` directory exists |
| T-00-2 | Hook installation is idempotent | Run `ccmux start` twice | Other fields in settings.json are preserved; hook entry appears exactly once |
| T-00-3 | Restart with existing session | tmux session and claude both running; restart daemon | Daemon attaches to existing session; does not kill claude; detects state via capture-pane and resumes |
| T-00-4 | Proxy not configured | Start without HTTP_PROXY set | Daemon logs a warning but does not abort startup |

---

### AC-01 Input FIFO Message Acceptance

**Criterion**: While the daemon is running, writing to any `in.*` FIFO delivers the content; daemon does not crash.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-01-1 | Plain text | `echo "hello" > /tmp/ccmux/in` | Daemon receives it; log entry recorded |
| T-01-2 | JSON | `echo '{"channel":"tg","content":"hi","ts":1000,"meta":{}}' > /tmp/ccmux/in` | Daemon correctly parses channel and content |
| T-01-3 | Invalid JSON | `echo '{bad' > /tmp/ccmux/in` | Treated as plain text; daemon does not crash |
| T-01-4 | Concurrent writers | 5 processes write to the same FIFO simultaneously | All messages received; no content interleaving |

---

### AC-02 Filesystem Dynamic Registration (inotify)

**Criterion**: When an adapter creates a FIFO, the daemon auto-discovers and starts reading it. When the FIFO disappears, the daemon stops reading it.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-02-1 | Dynamic input FIFO registration | Daemon running; `mkfifo /tmp/ccmux/in.test`; write a message | Daemon detects new FIFO; message received |
| T-02-2 | Input FIFO removal | Delete `in.test`; attempt to write | Daemon does not crash; logs FIFO deregistration |
| T-02-3 | Dynamic output FIFO registration | Create `out.test`; Claude calls `send_to_channel("test", "msg")` | Message written to `out.test`; adapter can read it |
| T-02-4 | Output FIFO does not exist | Call `send_to_channel("nonexist", "msg")` | Tool returns error to Claude; daemon does not crash; logs the event |

---

### AC-03 Message Injection into Claude Code

**Criterion**: After receiving a message, the daemon injects it via `tmux send-keys`; Mock Claude receives the input.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-03-1 | Single message injection | Send `{"content":"hello world"}` | `tmux capture-pane` shows `hello world` |
| T-03-2 | Chinese content | Send `{"content":"你好"}` | Pane shows `你好`, no corruption |
| T-03-3 | Multiple queued messages merged | Write 3 messages before stop hook fires | All 3 messages merged into one injection, format includes source and timestamp |
| T-03-4 | Injection format | Inject multi-source messages; inspect capture-pane | Format is `[HH:MM channel] content` one line per message |

---

### AC-04 Terminal Activity Detection

**Criterion**: Daemon reads `#{client_activity}` from tmux. When a human has used the terminal within `idle_threshold` seconds, injection is suppressed. Daemon injections via `send-keys` do not count as activity.

**Note**: `pipe-pane -I` is NOT used — it captures all PTY stdin including daemon's own send-keys injections, creating a circular dependency. `#{client_activity}` only tracks actual tmux client keyboard events.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-04-0a | `#{client_activity}` readable | Call `_get_client_activity_ts()` on real tmux pane | Returns int ≥ 0; never raises |
| T-04-0a2 | `_get_client_activity_ts()` fail-safe | Simulate pane cmd() raising; call `_get_client_activity_ts()` | Returns 0; `_is_terminal_active()` returns False (injection allowed) |
| T-04-0b | `send-keys` does not advance `#{client_activity}` | Inject text via `send-keys`; read `#{client_activity}` before and after | Timestamp unchanged — daemon injections are not human activity |
| T-04-1 | Suppress injection when terminal active | `_get_client_activity_ts()` returns current time; trigger `_maybe_inject()` with bare_pane set | Messages remain in queue (pane=None ruled out as cause) |
| T-04-2 | Resume injection after terminal idle | `_get_client_activity_ts()` returns 0; trigger `_maybe_inject()` | Messages injected; text visible in pane |
| T-04-3 | Idle threshold configurable | Set threshold to 5s; check boundary at 4s and 6s | 4s ago → active; 6s ago → idle |
| T-04-4 | Active → suppress → idle → inject sequence | Phase 1: active; Phase 2: idle | Messages suppressed in phase 1, drained and visible in pane in phase 2 |

---

### AC-05 Claude Ready Detection

**Criterion**: The detector correctly distinguishes "waiting for input", "generating", and "permission prompt" states.

| ID | Scenario | Mock Claude behavior | Expected result |
|----|----------|---------------------|----------------|
| T-05-1 | Normal prompt | default `MOCK_PROMPT=❯ `, no spinner; silence_timeout=1.0s | StdoutMonitor fires on_ready after silence; capture-pane last line contains `❯` → State.READY |
| T-05-2 | Silence timeout fallback | `MOCK_PROMPT=""` (no prompt); silence_timeout=1.0s | StdoutMonitor fires on_ready; capture-pane has no ❯ or spinner → State.UNKNOWN |
| T-05-3 | Permission prompt | `MOCK_PERMISSION_INTERVAL=1`; first turn outputs `Allow this action? Yes/No` | capture-pane keyword match → State.PERMISSION; injection suppressed |
| T-05-4 | Generating | `MOCK_SPINNER=15` (15 × 0.1s = 1.5s spinner burst); input "go" sent | At 0.5s: spinner chars on last capture-pane line → State.GENERATING; at 2.2s: prompt visible → State.READY |
| T-05-5 | Silence timeout configurable | silence_timeout=2.0s; write log once, no further writes | Not fired at 1.8s; fires exactly once at ≥2.0s |
| T-05-6 | reset() restarts silence timer | silence_timeout=1.0s; fire once; call reset(); no new file writes | on_ready fires a second time after reset() + silence_timeout |

---

### AC-06 Output Socket Full Broadcast

**Criterion**: After the stop hook fires, all subscribers receive the complete turn content within ≤ 1s.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-06-1 | Single subscriber | 1 client connected to output.sock | Receives broadcast |
| T-06-2 | Multiple subscribers | 3 clients connected; stop hook fires | All 3 receive identical broadcast; time difference ≤ 100ms |
| T-06-3 | No subscribers | Stop hook fires with 0 clients | Daemon does not crash; logs the event |
| T-06-4 | Subscriber disconnect | 1 client disconnects; broadcast fires | Remaining subscribers receive broadcast normally |

---

### AC-07 Output Socket Broadcast Format

**Criterion**: Broadcast payload is valid JSON containing the complete turn (not just text).

| ID | Scenario | Verification |
|----|----------|-------------|
| T-07-1 | Plain text reply | Contains `ts` (int), `session` (str), `turn` (array) |
| T-07-2 | Reply with thinking | `turn` contains `{"type":"thinking","thinking":"..."}` block if present |
| T-07-3 | Reply with tool call | `turn` contains `tool_use` and `tool_result` blocks |
| T-07-4 | `ts` accuracy | Differs from actual trigger time by ≤ 2s |

---

### AC-08 MCP Tool: send_to_channel

**Criterion**: After Claude calls `send_to_channel`, the message is written to the output FIFO and the adapter can read it.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-08-1 | Normal call | `out.telegram` exists; Claude calls the tool | Message written to FIFO; adapter reads it |
| T-08-2 | Target does not exist | `out.nonexist` absent; Claude calls the tool | Tool returns error; daemon logs it; does not crash |
| T-08-3 | Concurrent calls | Two `send_to_channel` calls in the same turn | Both messages written to their respective FIFOs |

---

### AC-09 Claude Code Crash Recovery

**Criterion**: After Mock Claude terminates, the daemon detects it and restarts with exponential backoff.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-09-1 | Single crash | `kill -9 <mock claude pid>` | Daemon detects crash within ≤ 3s and restarts; log recorded |
| T-09-2 | Normal operation after restart | Send a new message after restart | Message injected normally; pipe-pane re-mounted |
| T-09-3 | Exponential backoff | Kill 4 times consecutively | Restart intervals approximately 1s, 2s, 4s, 8s (error ≤ 50%, accounting for process poll interval) |
| T-09-4 | Backoff cap | Kill 10 times consecutively | Interval stabilizes at 60s (±10s) |

---

### AC-10 Structured Logging

**Criterion**: Key events produce structured JSON log entries with required fields.

| Event | Required fields |
|-------|----------------|
| FIFO register/deregister | `event`, `ts`, `path` |
| Message received | `event`, `ts`, `channel`, `content_len` |
| Message injected | `event`, `ts`, `message_count` |
| Ready detected | `event`, `ts`, `method` (`prompt`/`timeout`/`skipped`) |
| Broadcast sent | `event`, `ts`, `subscriber_count` |
| Tool call | `event`, `ts`, `channel`, `message_len` |
| Process crash | `event`, `ts`, `restart_count` |
| Process restart | `event`, `ts`, `restart_count`, `backoff_seconds` |

| ID | Scenario | Verification |
|----|----------|-------------|
| T-10-1 | Full injection flow | Log contains: receive → ready → inject → broadcast, in correct order |
| T-10-2 | Crash recovery | Log contains crash + restart + backoff_seconds event sequence |
| T-10-3 | Invalid input | Log contains an `error`-level entry |

---

### AC-11 Graceful Shutdown

**Criterion**: After SIGTERM, all sockets are closed, no orphan processes remain, exit code is 0.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-11-1 | Normal shutdown | Send SIGTERM | Exits within 5s; exit code 0; socket files cleaned up |
| T-11-2 | Active subscriber during shutdown | Subscriber connected; send SIGTERM | Subscriber connection closed; daemon exits normally |
| T-11-3 | Injection in progress during shutdown | Send SIGTERM during injection | Current injection completes or times out before exit; no hung processes |

---

### AC-12 ccmux Daemon Restart and Reconnect

**Criterion**: After the ccmux daemon restarts, it attaches to the existing tmux session and resumes normal operation without interrupting the Claude session.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-12-1 | Daemon restarts while claude is running | Kill daemon; let claude complete a turn; start daemon again | Daemon attaches to existing session; does not restart claude; re-mounts pipe-pane |
| T-12-2 | Injection resumes after restart | Write to FIFO after daemon restarts | Message received and injected; Mock Claude receives it |
| T-12-3 | Broadcast resumes after restart | Stop hook fires after daemon restarts | Subscribers receive broadcast |
| T-12-4 | Claude in permission prompt during restart | Daemon restarts; claude is at permission prompt | Daemon detects permission prompt state; does not inject; logs the state |

---

### AC-13 PermissionRequest Routing

**Criterion**: When a permission prompt is detected, automatic injection is suppressed and an alert is routed to the human channel.

| ID | Scenario | Action | Expected result |
|----|----------|--------|----------------|
| T-13-1 | PermissionRequest hook fires | Mock Claude emits permission prompt (`MOCK_PERMISSION_INTERVAL=1`) | Daemon receives PermissionRequest hook; stops automatic injection; broadcasts `permission_request` alert to output.sock subscribers |
| T-13-2 | capture-pane fallback detection | Hook does not fire but capture-pane finds permission keywords | Daemon still stops injection; logs detection source as `capture-pane` |
| T-13-3 | Injection resumes after permission resolved | Human resolves the permission prompt; claude returns to ready | Daemon detects ready state; resumes automatic injection |
| T-13-4 | capture-pane recovery clears stale flag | `_permission_detected` set by hook, but capture-pane shows no permission text (user resolved without Stop hook) | Flag cleared; queued messages injected |

---

## Pass Criteria

- Unit tests: 100% pass
- Integration tests: 100% pass (AC-00 through AC-13 fully covered)
- All 5 spikes (SP-01 through SP-05) have written findings, updated in spec.md
- No skipped test items

## Test Commands

```bash
# Mock tests only (no proxy needed; runs in CI)
.venv/bin/python -m pytest tests/ -m "not real_claude" -v

# real_claude tests (requires proxy running on port 8118)
# Proxy check is automatic — tests skip cleanly if proxy is down
.venv/bin/python -m pytest tests/ -m real_claude -v

# All tests
.venv/bin/python -m pytest tests/ -v

# Coverage
.venv/bin/python -m pytest tests/ --cov=ccmux --cov-report=term-missing
```

**real_claude tests** use the `real_claude_proxy` fixture which:
- Checks `http://127.0.0.1:8118` proxy availability via curl
- Sets `test_config.claude_proxy` (NOT `os.environ`) — only the `claude` process in the tmux pane uses the proxy via `_proxy_env_prefix(cfg)` inline in `send_keys`; the test process and all other subprocesses are unaffected
- Skips cleanly (not fails) if proxy is down — safe to include in any test run

---

## Iteration Status

_This section is the single source of truth for development progress. Update it at the end of each iteration. New sessions should read this before starting any work._

### Completed

| Iteration | Scope | Tests | Notes |
|-----------|-------|-------|-------|
| Iter-0 | Core infrastructure: pubsub, hook, hooks_manager, injector, fifo, watcher, detector, lifecycle, mcp_server, daemon | 53 tests passing (AC-01✅ AC-03✅ AC-06✅ AC-07 partial AC-11 partial) | Baseline implementation |
| Iter-1 | AC-04: Terminal activity detection via `#{client_activity}` | 60 tests passing (+7) | Removed pipe-pane -I and dead code; verified design premise (T-04-0a/0a2/0b); empirically confirmed server-wide scope; 3 closure rounds, 2 consecutive clean |
| Iter-2 | AC-05: Ready detection (StdoutMonitor + ReadyDetector GENERATING fix) | 66 tests passing (+6) | Fixed dead `_check_generating()` call in `get_state()`; fixed `reset()` not clearing `_last_mtime`; added `make_mock_pane` factory fixture; T-05-1~6 all pass |
| Iter-3 | AC-02: Output FIFO channel write (T-02-3/T-02-4) | 68 tests passing (+2) | Extracted `_send_to_channel` coroutine from MCP closure (testable); wired `on_output_add/remove` callbacks in daemon; T-02-3 verifies FIFO write end-to-end; T-02-4 verifies error return + warning logged |
| Iter-4 | AC-09: Crash recovery (T-09-1~4) | 70 tests passing (+2) | Added poll_interval param to LifecycleManager (testable); fixed restart cmd (always CLAUDE_CONTINUE_CMD); T-09-1 verifies crash detection timing + log; T-09-2 verifies correct restart cmd; T-09-3 lower+upper bound on backoff intervals; T-09-4 cap verified via mocked asyncio.sleep |
| Iter-5 | AC-13 (PermissionRequest routing) + AC-06 real pipeline | 75 tests passing (+5) | Fixed `_check_permission_prompt` false positive (last 5 lines + ❯-at-end guard); fixed `_permission_detected` sticky flag (cleared in `_on_broadcast` on Stop hook); fixed daemon.py `log.info("hook event received", event=event)` structlog keyword conflict (renamed to `hook_event=event`); T-13-1/3: fire_hook + bare_pane; T-13-2: bare_pane typed text; T-06-real: hook.py→control.sock→output.sock pipeline. **Post-review fixes**: (1) MCP startup race resolved — `run_server()` signals `asyncio.Event` after port bind, daemon awaits before `_write_mcp_config()`; (2) AC-13 alert broadcast — permission_request event sent to output.sock subscribers (T-13-1 verifies); (3) capture-pane recovery — stale `_permission_detected` flag cleared when capture-pane no longer shows permission text (T-13-4) |
| Iter-6 | AC-07 mock complete + AC-10 logging + lifecycle restart bug | 80 tests passing (+5) | T-07-2/3: thinking + tool_use block passthrough via crafted transcripts; T-10-1: injection flow log order (receive→ready→inject→broadcast) with field assertions; T-10-2: crash recovery log fields (restart_count, backoff_seconds); T-10-3: error-level log on injection failure; lifecycle.py `_build_restart_cmd()` includes proxy env vars + CCMUX_CONTROL_SOCK. **Closure fixes**: AC-10 spec text order corrected; AC-10 crash event field updated (pid→restart_count); AC-07 ts fallback masking removed. 2 closure rounds, 2 consecutive clean. |
| Iter-7a | Production readiness: P0/P1 fixes + AC-12 + E2E smoke | 89 tests passing (+9) | **P0-2**: hook.py `_log_error()` replaces silent `except: pass` — writes JSONL to `hook_errors.log` + stderr, self-truncates at 100KB (3 tests). **P0-1**: `stdout_log_max_bytes` config + `StdoutMonitor` truncation + pipe-pane remount callback (1 test). **P1-1**: `_is_claude_running()` fail-safe changed from `return True` to `return False` + warning log (1 test). **P1-2**: transcript watcher deferred in spec.md; known issue added. **P1-3**: AC-12 T-12-1/2/3 (daemon re-attach, injection, broadcast after restart). **P1-4**: E2E mock smoke test (full chain: FIFO→queue→inject→hook→broadcast). |

| Iter-7b | AC-00 + AC-11 + real_claude pass | 87 tests (mock) + real_claude pass | Code cleanup, live-test bug fixes, project-level config migration |
| Iter-8 | WhatsApp integration: wa-notifier + whatsapp-mcp + E2E pipeline | 120 tests passing (+33) | See Iter-8 findings below |

### Iter-8: WhatsApp Integration Findings (2026-02-21)

**Architecture**: Hybrid — whatsapp-mcp (external MCP server) gives Claude direct WhatsApp tools, wa-notifier (our code, ~300 lines) polls bridge's SQLite and writes push notifications to ccmux FIFO.

**Critical issues found & fixed**:

1. **HTTP_PROXY breaks whatsapp-mcp write operations** — ccmux sets `HTTP_PROXY` for Claude API access. Claude spawns whatsapp-mcp as child MCP server, which inherits the proxy env. Python `requests` routes `localhost:8080` bridge calls through the proxy, causing HTTP 500. **Fix**: `NO_PROXY=localhost,127.0.0.1` added to proxy env prefix in `daemon.py` and `lifecycle.py`.

2. **Timestamp format (3 iterations to fix)** — Go bridge stores `time.Time` as `"2026-02-21 16:14:59+08:00"` (space separator, TZ offset). Initially used `int`, then ISO with `T` separator, finally `_init_last_seen()` reads `max(timestamp)` from DB directly. **Lesson**: never generate timestamps for comparison with external sources.

3. **SQLite column name** — bridge uses `content` not `body`. Caught in security audit before runtime.

4. **SQLite WAL mode** — required for concurrent read (notifier) + write (bridge). Patched bridge connection string.

**whatsapp-mcp capability validation** (live, 2026-02-21):

| Tool | Type | Status | Notes |
|------|------|--------|-------|
| search_contacts | Read (SQLite) | PASS | |
| list_chats | Read (SQLite) | PASS | |
| list_messages | Read (SQLite) | PASS | |
| send_message | Write (HTTP) | PASS | Requires NO_PROXY fix |
| send_file | Write (HTTP) | PASS | Requires NO_PROXY fix |
| send_audio_message | Write (HTTP) | PASS | Requires ffmpeg (`~/bin/ffmpeg`) |
| download_media | Write (HTTP) | PASS | Requires NO_PROXY fix |

**Security**: Bridge HTTP API patched to bind `127.0.0.1` only. Known accepted risks: arbitrary file read via `send_file`, prompt injection via incoming messages.

**Operational**: Bridge syncs ~4500 history messages on first link; `_init_last_seen()` skips all. Bridge must run before notifier. ffmpeg installed as static binary to `~/bin/`.

**E2E pipeline verification** (live, 2026-02-21):

| Hop | Method | Status | Latency |
|-----|--------|--------|---------|
| FIFO → daemon receives | Write to `/tmp/ccmux/in`, check daemon log | PASS | <1ms |
| daemon → injection | Check daemon log `injecting messages` | PASS | 5ms |
| Claude sees notification | `tmux capture-pane` shows `[HH:MM whatsapp]` | PASS | immediate |
| Claude calls `list_messages` | Claude autonomously invokes MCP tool | PASS | ~5s (LLM turn) |
| Claude → `send_message` | Validated in previous session (contacta) | PASS | ~3s |
| wa-notifier → SQLite poll | Unit test + live poll log | PASS | 30s interval |
| All 4 MCP servers connected | `/mcp` shows ccmux, whatsapp, futu-stock, google-calendar | PASS | — |

**Lifecycle fixes** (found during E2E):
1. **lifecycle.py structlog migration** — used stdlib `logging` instead of `structlog`; messages appeared as plain text. Fixed.
2. **Post-restart grace period** — after restart command, monitor re-checked in 2s before Claude finished starting (~10s). Added `await asyncio.sleep(startup_grace)` after restart.
3. **Auto-inject on message receipt** — `StdoutMonitor._fired` prevents re-firing `on_ready` after first trigger. Messages arriving while Claude is idle were never injected. Fixed by calling `_maybe_inject()` in `_on_message()`.
4. **Exception handling in `_monitor` task** — unhandled exceptions silently killed the asyncio task. Added try/except with CancelledError re-raise.

### Pending

_Each iteration is complete only when both its mock and real_claude tests pass. real_claude tests run manually at each iteration milestone (marked `@pytest.mark.real_claude`, skipped in CI)._

(No pending items.)

### Backlog

| Item | Notes |
|------|-------|
| Voice message transcription | Claude cannot process audio. Need STT component (faster-whisper local or Whisper API). Flow: download_media → ffmpeg → STT → text. Deferred. |

### Known Issues (carry-forward)

| File | Issue | Affects |
|------|-------|---------|
| `ccmux/lifecycle.py:_is_claude_running` | Process detection logic (pgrep + capture-pane fallback) is never exercised by tests; all AC-09 tests monkeypatch this method. Real coverage requires `bare_pane` + actual process kill. | AC-09 |
| `mock_pane.py` PTY stdin behavior | `mock_pane`'s `sys.stdin.readline()` for the permission-resolution wait returns immediately (empty string) in a PTY context. AC-13 tests worked around this by using `fire_hook` + `bare_pane` instead. | AC-13 |
| Broadcast chain single point of failure | Broadcast chain depends on Stop hook → hook.py → control.sock. If daemon is down, payloads are lost. Mitigation: hook.py error logging (P0-2) writes failed payloads to `hook_errors.log` with structured JSONL. Transcript watcher fallback is deferred. | AC-06, AC-07 |
